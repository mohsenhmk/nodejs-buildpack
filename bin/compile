#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-dir>

set -e
set -o pipefail   # dont ignore exit codes when piping output
set -o nounset    # fail on unset variables
unset GIT_DIR     # Avoid GIT_DIR leak from previous build steps


#===============================
# R
shopt -s extglob

function error() {
  echo " !     $*" >&2
  exit 1
}

function indent() {
  c='s/^/       /'
  case $(uname) in
    Darwin) sed -l "$c";;
    *)      sed -u "$c";;
  esac
}

function read_var() {
  echo $(head -n 1 $1)
}
# R
#==============================
### Constants

DEFAULT_CACHE="node_modules bower_components"

### Configure directories

BUILD_DIR=${1:-}
CACHE_DIR=${2:-}
ENV_DIR=${3:-}
BP_DIR=$(cd $(dirname ${0:-}); cd ..; pwd)
$BP_DIR/compile-extensions/bin/check_stack_support
$BP_DIR/compile-extensions/bin/check_buildpack_version $BP_DIR $CACHE_DIR



#===============================
# R

R_CACHE_DIR="$2/vendor"
LP_DIR=`cd $(dirname $0); cd ..; pwd`
BUILDPACK_DIR="$(dirname $(dirname $0))"
GCC_VERSION=4.8

# R
#==============================


mkdir -p "$BUILD_DIR/.heroku/node/"
cd $BUILD_DIR
export PATH="$BUILD_DIR/.heroku/node/bin:$BUILD_DIR/.heroku/yarn/bin":$PATH

# CF Common
export BUILDPACK_PATH=$BP_DIR
source $BP_DIR/compile-extensions/lib/common
# END CF Common
LOG_FILE='/tmp/node-build-log.txt'
echo "" > "$LOG_FILE"

### Load dependencies

source $BP_DIR/lib/output.sh
source $BP_DIR/lib/json.sh
source $BP_DIR/lib/failure.sh
source $BP_DIR/lib/environment.sh
source $BP_DIR/lib/binaries.sh
source $BP_DIR/lib/cache.sh
source $BP_DIR/lib/dependencies.sh
source $BP_DIR/lib/vendor/new_relic/install.sh $BUILD_DIR

### Handle errors

handle_failure() {
  header "Build failed"
  warn_untracked_dependencies "$LOG_FILE"
  warn_angular_resolution "$LOG_FILE"
  warn_missing_devdeps "$LOG_FILE"
  warn_econnreset "$LOG_FILE"
  failure_message | output "$LOG_FILE"
}
trap 'handle_failure' ERR

### Check initial state

[ -e "$BUILD_DIR/node_modules" ] && PREBUILD=true || PREBUILD=false
[ -f "$BUILD_DIR/yarn.lock" ] && YARN=true || YARN=false

node_modules_subdirs=0
if [ -d "$BUILD_DIR/node_modules" ]; then
  node_modules_subdirs=$(find "$BUILD_DIR"/node_modules -mindepth 1 -maxdepth 1 -type d | wc -l)
fi

if [ "$node_modules_subdirs" -eq 0 ]; then
	info "PRO TIP: It is recommended to vendor the application's Node.js dependencies"
	info "         See http://docs.cloudfoundry.org/buildpacks/node/index.html#vendoring for more information"
fi

### Failures that should be caught immediately

fail_invalid_package_json "$BUILD_DIR"
warn_prebuilt_modules "$BUILD_DIR"
warn_missing_package_json "$BUILD_DIR"

### Compile

create_env() {
  write_profile "$BP_DIR" "$BUILD_DIR"
  export_env_dir "$ENV_DIR"
  create_default_env
}

header "Creating runtime environment"
create_env # can't pipe the whole thing because piping causes subshells, preventing exports
list_node_config | output "$LOG_FILE"

install_bins() {
  local node_engine=$(read_json "$BUILD_DIR/package.json" ".engines.node")
  local iojs_engine=$(read_json "$BUILD_DIR/package.json" ".engines.iojs")
  local npm_engine=$(read_json "$BUILD_DIR/package.json" ".engines.npm")
  local yarn_engine=$(read_json "$BUILD_DIR/package.json" ".engines.yarn")

  if [ -n "$iojs_engine" ]; then
    echo "engines.iojs (package.json):  $iojs_engine (iojs)"
  else
    echo "engines.node (package.json):  ${node_engine:-unspecified}"
  fi
  echo "engines.npm (package.json):   ${npm_engine:-unspecified (use default)}"
  echo ""

  if [ -n "$iojs_engine" ]; then
    warn_node_engine "$iojs_engine"
    install_iojs "$iojs_engine" "$BUILD_DIR/.heroku/node"
    echo "Using bundled npm version for iojs compatibility: `npm --version`"
  else
    warn_node_engine "$node_engine"
    install_nodejs "$node_engine" "$BUILD_DIR/.heroku/node"
    install_npm "$npm_engine" "$BUILD_DIR/.heroku/node"
  fi
  if $YARN; then
    install_yarn "$BUILD_DIR/.heroku/yarn" "$yarn_engine"
  fi
}

header "Installing binaries"
install_bins | output "$LOG_FILE"

restore_cache() {
  local cache_status="$(get_cache_status)"

  if [ "$cache_status" == "valid" ]; then
    local cache_directories=$(get_cache_directories)
    if [ "$cache_directories" == "" ]; then
      echo "Loading 2 from cacheDirectories (default):"
      restore_cache_directories "$BUILD_DIR" "$CACHE_DIR" "$DEFAULT_CACHE"
    else
      echo "Loading $(echo $cache_directories | wc -w | xargs) from cacheDirectories (package.json):"
      restore_cache_directories "$BUILD_DIR" "$CACHE_DIR" $cache_directories
    fi
  else
    echo "Skipping cache restore ($cache_status)"
  fi
}

header "Restoring cache"
restore_cache | output "$LOG_FILE"

build_dependencies() {
  run_if_present 'heroku-prebuild'
  if $YARN; then
    yarn_node_modules "$BUILD_DIR"
  elif $PREBUILD; then
    echo "Prebuild detected (node_modules already exists)"
    npm_rebuild "$BUILD_DIR"
  else
    npm_node_modules "$BUILD_DIR"
  fi
  run_if_present 'heroku-postbuild'
  # TODO: run_if_present 'build'
}

header "Building dependencies"
build_dependencies | output "$LOG_FILE"

cache_build() {
  local cache_directories=$(get_cache_directories)

  echo "Clearing previous node cache"
  clear_cache
  if ! ${NODE_MODULES_CACHE:-true}; then
    echo "Skipping cache save (disabled by config)"
  elif [ "$cache_directories" == "" ]; then
    echo "Saving 2 cacheDirectories (default):"
    save_cache_directories "$BUILD_DIR" "$CACHE_DIR" "$DEFAULT_CACHE"
  else
    echo "Saving $(echo $cache_directories | wc -w | xargs) cacheDirectories (package.json):"
    save_cache_directories "$BUILD_DIR" "$CACHE_DIR" $cache_directories
  fi
  save_signature
}

header "Caching build"
cache_build | output "$LOG_FILE"

summarize_build() {
  list_dependencies "$BUILD_DIR"
}

header "Build succeeded!"
$BP_DIR/compile-extensions/bin/store_buildpack_metadata $BP_DIR $CACHE_DIR
summarize_build | output "$LOG_FILE"

#=============================
# R

# fix STACK variable if unset
if [ -z "${STACK}" ];
then
  STACK="cedar-14"
fi

# config

# read in R version if file exists
if [[ -f $BUILD_DIR/.r-version ]]; then
  R_VERSION=`read_var $BUILD_DIR/.r-version`
else
  #R_VERSION="3.2.4" Latest buildpack has bugs with shiny per https://github.com/virtualstaticvoid/heroku-buildpack-r/issues/56.  Use older version of R that is compatible
  R_VERSION="3.2.1"

fi

# read in buildback binary version if file exists
if [[ -f $BUILD_DIR/.r-buildpack-version ]]; then
  BUILD_PACK_VERSION=`read_var $BUILD_DIR/.r-buildpack-version`
else
  #BUILD_PACK_VERSION="20160322-0811" Latest buildpack has bugs with shiny per https://github.com/virtualstaticvoid/heroku-buildpack-r/issues/56.  Use older version of buildpack that is compatible
  BUILD_PACK_VERSION="20150719-0045" 
fi

S3_BUCKET="heroku-buildpack-r"
R_BINARIES="http://${S3_BUCKET}.s3.amazonaws.com/${STACK}/R-${R_VERSION}-binaries-${BUILD_PACK_VERSION}.tar.gz"

VENDOR_DIR="$BUILD_DIR/vendor"
CRAN_MIRROR="http://cran.revolutionanalytics.com"

mkdir -p $CACHE_DIR

# vendor R into the slug
echo "Vendoring R $R_VERSION for $STACK stack ($BUILD_PACK_VERSION)" | indent

# download and unpack binaries
echo "Downloading and unpacking R binaries ($R_BINARIES)" | indent
curl $R_BINARIES -s -o - | tar xzf - -C $BUILD_DIR

# also using buildpack-apt?
if [ -d $BUILD_DIR/.apt ]; then
  cp -r $VENDOR_DIR/.apt/ $BUILD_DIR
else
  mv $VENDOR_DIR/.apt/ $BUILD_DIR
fi





# need to copy the binaries to /app/vendor so that R works when compiling packages

mkdir -p /app/.apt







# source "$BUILDPACK_DIR/bin/installgfortran.sh" -d "/app/vendor/R/bin/gfortran" "4.8"

LP_DIR=`cd $(dirname $0); cd ..; pwd`

function indent() {
  c='s/^/       /'
  case $(uname) in
    Darwin) sed -l "$c";;
    *)      sed -u "$c";;
  esac
}
echo "Updating apt caches"

APT_CACHE_DIR="$CACHE_DIR/apt/cache"
APT_STATE_DIR="$CACHE_DIR/apt/state"
mkdir -p "$APT_CACHE_DIR/archives/partial"
mkdir -p "$APT_STATE_DIR/lists/partial"
APT_OPTIONS="-o debug::nolocking=true -o dir::cache=$APT_CACHE_DIR -o dir::state=$APT_STATE_DIR"
apt-get $APT_OPTIONS update | indent
apt-get $APT_OPTIONS -y --force-yes -d install --reinstall gfortran | indent

# apt-get $APT_OPTIONS -y --force-yes -d install --reinstall libv8-dev | indent
cp $BUILD_DIR/pandoc.deb $APT_CACHE_DIR/archives/
for DEB in $(ls -1 $APT_CACHE_DIR/archives/*.deb); do
  echo "Installing $(basename $DEB)"
  dpkg -x $DEB $BUILD_DIR/.apt/
done

# echo "findstuf"
# cd $BUILD_DIR/.apt/
# ls -R | grep libv8




cp -R $BUILD_DIR/.apt/* /app/.apt

mkdir -p /app/vendor/R
cp -R $VENDOR_DIR/R/* /app/vendor/R

uname -a

# trialed and errored on this; copy over libs to gfortran, so
# that liblto_plugin.so and others can be found
# (tried using LDFLAGS, LD_LIBRARY_PATH and LIBRARY_PATH but didn't work)

cp -R /usr/lib/gcc/x86_64-linux-gnu/$GCC_VERSION/* /app/.apt/usr/lib/gcc/x86_64-linux-gnu/$GCC_VERSION
# cp /usr/lib/gcc/x86_64-linux-gnu/$GCC_VERSION/liblto_plugin.so /app/.apt/usr/lib/gcc/x86_64-linux-gnu/$GCC_VERSION/liblto_plugin.so

# set environment variables, needed for compiling packages
source "$BUILDPACK_DIR/bin/r_environment.sh"
# copy over environment
mkdir -p $BUILD_DIR/.profile.d
cp "$BUILDPACK_DIR/bin/r_environment.sh" "$BUILD_DIR/.profile.d/r_environment.sh"

# prevent warnings when building packages
mkdir -p /app/vendor/R/lib64/R/doc/html
touch /app/vendor/R/lib64/R/doc/html/R.css


# install dependencies from CRAN
echo $CF_STAGING_TIMEOUT
echo "Executing init.r script" | indent

# set the CRAN mirror and run the init.r program
/app/vendor/R/bin/R -s <<RPROG > indent
  Sys.setenv(BUILD_DIR="$BUILD_DIR")
  print(.libPaths())
  .libPaths("$BUILD_DIR")
  print(.libPaths())
  setwd("$BUILD_DIR")
  r <- getOption("repos");
  r["CRAN"] <- "$CRAN_MIRROR";
  options(repos=r);
  `cat $BUILD_DIR/init.r`
RPROG

echo "R $R_VERSION successfully installed" | indent

# need to copy binaries back so that any
# installed packages are included in the slug
rm -rf $VENDOR_DIR/R
mkdir -p $VENDOR_DIR/R
cp -R /app/vendor/R/* $VENDOR_DIR/R

# R
#================================


warn_no_start "$LOG_FILE"
warn_unmet_dep "$LOG_FILE"
